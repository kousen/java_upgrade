package streams;

import com.sun.security.jgss.GSSUtil;
import org.junit.jupiter.api.Test;

import java.nio.file.DirectoryStream;
import java.util.*;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.stream.Collectors;

public class StringExercises {
    private final List<String> strings = List.of("this", "is", "a",
            "list", "of", "strings");

    @Test
    public void stringLengthSort_InnerClass() {     // Java 5, 6, 7
        // Cannot modify a list produced by List.of
//        strings.sort(new Comparator<String>() {
//            @Override
//            public int compare(String s1, String s2) {
//                return s1.length() - s2.length();
//            }
//        });

        var mutableStrings = new ArrayList<>(strings);
        // sort by length
        mutableStrings.sort(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                return s1.length() - s2.length();
            }
        });
        System.out.println(mutableStrings);
    }

    @Test
    public void stringLengthSort_lambda() {
        // Use lambda for the Comparator (reverse sort)
        var mutableStrings = new ArrayList<>(strings);
        mutableStrings.sort((s1, s2) -> s2.length() - s1.length());
        System.out.println(mutableStrings);

        // Use the "sorted" method on Stream
        List<String> sorted = strings.stream()
                .sorted((s1, s2) -> s2.length() - s1.length())
                .toList();
        System.out.println("Sorted list: " + sorted);
        System.out.println("Original list: " + strings);
    }

    private int compareStrings(String s1, String s2) {
        return s1.length() - s2.length();
    }

    @Test  // Use a lambda that calls 'compareStrings' directly
    public void stringLengthSort_methodCall() {

    }

    @Test  // Use a method ref to 'compareStrings'
    public void stringLengthSort_methodRef() {

    }

    @Test  // Use Comparator.comparingInt
    public void stringLengthSort_comparingInt() {
        List<String> sorted = strings.stream()
                .sorted(Comparator.comparingInt(String::length)
                        .thenComparing(Comparator.naturalOrder()))
                .toList();
        System.out.println("Sorted list: " + sorted);
        System.out.println("Type of list: " + sorted.getClass().getName());
    }

    @Test
    public void demoCollectors() {
        // Get only strings of even length
        // Add them to a LinkedList
        List<String> evenLengthStrings = strings.stream()
                .filter(s -> s.length() % 2 == 0)
                .collect(Collectors.toCollection(LinkedList::new));
        System.out.println("Even length strings: " + evenLengthStrings);
        System.out.println("Type of list: " + evenLengthStrings.getClass().getName());

        // Add the strings to a map of string to length
        Map<String, Integer> stringLengthMap = strings.stream()
                .collect(Collectors.toMap(t -> t, String::length));
        System.out.println("String length map: " + stringLengthMap);
        System.out.println("Type of map: " + stringLengthMap.getClass().getName());

        // Filter out nulls, then print even-length strings
        List<String> stringsWithNulls = Arrays.asList("this", null, "is", null, null,
                "a", "list", "of", "strings", null);
        // 1. Short-circuiting logical AND
        // 2. Two consecutive filter calls, using an actual null check
        // 3. Filter out nulls using Objects::nonNull
        // 4. Composition!
        stringsWithNulls.stream()
                //.filter(s -> s != null && s.length() % 2 == 0) // short-circuiting logical AND
                .filter(Objects::nonNull)
                .filter(s -> s.length() % 2 == 0)
                .forEach(System.out::println);

        // Function composition
        Logger logger = Logger.getLogger(StringExercises.class.getName());
        Consumer<String> logString = logger::info;
        Consumer<String> printer = System.out::println;
        Consumer<String> logAndPrint = logString.andThen(printer);

        Predicate<String> evenLengthPredicate = (String s) -> s.length() % 2 == 0;
        Predicate<String> nonNullPredicate = Objects::nonNull;
        Predicate<String> composedPredicate = nonNullPredicate.and(evenLengthPredicate);
        stringsWithNulls.stream()
                .filter(composedPredicate)
                .forEach(logAndPrint);

        // Combine the two predicates and use the result to print non-null, even-length strings

        // f: A -> B, g: B -> C, (g.f)(x) = g(f(x)), A -> C
    }

    // generated by GitHub Copilot
    private <A, B, C> Function<A, C> compose(Function<A, B> f, Function<B, C> g) {
        return x -> g.apply(f.apply(x));
    }

    private <A, B> void functionThenPredicateThenConsumer(Function<A, B> f,
                                                          Predicate<B> p,
                                                          Consumer<Boolean> c) {
        c.accept(p.test(f.apply(null)));
    }

}
